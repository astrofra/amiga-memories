<Version=1.0>
<Shader=
	<Input=
		<Attribute=<Name="a_position"><Semantic="Position">>

		<Uniform=<Name="u_sky"><Semantic="NormalMatrix">>
		<Uniform=<Name="u_time_of_day"><Semantic="TimeOfDay">>
		<Uniform=<Name="u_ratio"><Semantic="ViewportRatio"><Scope=<Vertex>>>

		<Uniform=<Name="u_zoom_factor"><Semantic="ZoomFactor"><Scope=<Vertex>>>
		
		<Uniform=<Name="fog_color"><Semantic="FogColor">>
		<Uniform=<Name="fog_near"><Semantic="FogNear">>
		<Uniform=<Name="fog_far"><Semantic="FogFar">>
		<Uniform=<Name="ambient_color"><Semantic="AmbientColor">>
		
		<Uniform=<Name="u_layer0"><Semantic="Texture">>
	>
	<Varying=
		<Variable=<Name="v_uv"><Type="vec2">>
	>
	<VertexSource=
"
float factor = 1.0 / u_zoom_factor;
v_uv = (a_position.xy * vec2(factor, factor)) / u_ratio;
%out.position% = vec4(a_position, 1.0);
"
	>
	<PixelDeclaration=
"
float phase(float alpha, float g)
{
	float g2 = g * g;
	float a = 3.0 * (1.0 - g2);
	float b = 2.0 * (2.0 + g2);
	float c = 1.0 + alpha * alpha;
	float d = pow(1.0 + g2 - 2.0 * g * alpha, 1.5);
	return (a / b) * (c / d);
}

float atmospheric_depth(vec3 position, vec3 dir)
{
	float a = dot(dir, dir);
	float b = 2.0 * dot(dir, position);
	float c = dot(position, position) - 1.0;
	float det = b * b - 4.0 * a * c;
	float detSqrt = sqrt(det);
	float q = (-b - detSqrt) / 2.0;
	float t1 = c / q;
	return t1;
}

float horizon_extinction(vec3 position, vec3 dir, float radius)
{
	float u = dot(dir, -position);
	if	(u < 0.0)
		return 1.0;

	vec3 near = position + u * dir;
	if	(length(near) < radius)
		return 0.0;

	vec3 v2 = normalize(near) * radius - position;
	float diff = acos(dot(normalize(v2), dir));
	return smoothstep(0.0, 1.0, pow(diff * 2.0, 3.0));
}

#define Kr vec3(0.18867780436772762, 0.4978442963618773, 0.6616065586417131)

vec3 absorb(float dist, vec3 color, float factor)
{
	float k = factor / dist;
	return color - color * pow(Kr, vec3(k, k, k));
}

vec4 SampleCloudTexture(vec3 v)
{
	float r = sqrt(v.x * v.x + v.z * v.z);
	
	float lat = acos(clamp(v.x / r, -1.0, 1.0));
	lat /= 3.1415926535 * 2.0;
	if	(v.z > 0.0)
		lat = 1.0 - lat;
	
	float lon = asin(v.y) / 3.1415926535 + 0.5;
	lon = 1.0 - lon;
	
	float clamped_lon;
	if (lon < 0.5)
		clamped_lon = lon * 2.0;
	else
		clamped_lon = 1.0;

	float	_seam = 1.0;
	if (lat < 0.1)
		_seam = clamp(lat * 10.0, 0.0, 1.0);
	else
	if (lat > 0.9)	
		_seam = clamp((1.0 - (lat - 0.9) * 10.0), 0.0, 1.0);
		
	_seam *= clamp((lon * 5.0), 0.0, 1.0);
	return (texture2D(u_layer0, vec2(lat, clamped_lon)) * _seam);
//		return vec4(lat, clamped_lon, 0, 1);
}

"
	>
	<PixelSource=
"
float rayleigh_strength = 0.3;
float rayleigh_brightness = 2.5;
float rayleigh_collection_power = 0.20;

float mie_strength = 0.001;
float mie_brightness = 0.05;
float mie_collection_power = 0.01;
float mie_distribution = 0.001;

float spot_brightness = 2.0;
float scatter_strength = 0.025;

float step_count = 2.0;
float intensity = 1.0;
float surface_height = 0.994;

vec3 v = vec3(v_uv, 1.0);
v = n_mtx_mul(u_sky, normalize(v));

vec3 cloud_tex = SampleCloudTexture(v).rgb;

//
float lat = 0.3; //u_time_of_day * 3.141592 * 2.0;
float lon = u_time_of_day * 3.141592 * 2.0 - 3.141592;

vec3 lightdir = vec3(sin(lon) * sin(lat), cos(lon), sin(lon) * cos(lat));
lightdir = normalize(lightdir);

vec3 eyedir = v;
float alpha = dot(eyedir, lightdir);

//
spot_brightness *= cloud_tex.x;
float rayleigh_factor = phase(alpha, -0.01) * rayleigh_brightness;
float mie_factor = phase(alpha, mie_distribution) * mie_brightness;
float spot = smoothstep(0.0, 15.0, phase(alpha, 0.9995)) * spot_brightness * (1.0 - cloud_tex.y);

//
vec3 eye_position = vec3(0.0, surface_height, 0.0);
float eye_depth = atmospheric_depth(eye_position, eyedir);
float step_length = eye_depth / step_count;
float eye_extinction = horizon_extinction(eye_position, eyedir, surface_height - 0.15);

//
vec3 rayleigh_collected = vec3(0.0, 0.0, 0.0);
vec3 mie_collected = vec3(0.0, 0.0, 0.0);

for	(float i = 0; i < step_count; i++)
{
	float sample_distance = step_length * i;
	vec3 position = eye_position + eyedir * sample_distance;
	float extinction = horizon_extinction(position, lightdir, surface_height - 0.35);
	float sample_depth = atmospheric_depth(position, lightdir);

	vec3 influx = absorb(sample_depth, vec3(intensity, intensity, intensity), scatter_strength) * extinction;
	rayleigh_collected += absorb(sample_distance, Kr * influx, rayleigh_strength);
	mie_collected += absorb(sample_distance, influx, mie_strength);
}

//
rayleigh_collected = (rayleigh_collected * eye_extinction * pow(eye_depth, rayleigh_collection_power)) / step_count;
mie_collected = (mie_collected * eye_extinction * pow(eye_depth, mie_collection_power)) / float(step_count);

vec3 color = vec3(spot * mie_collected + mie_factor * mie_collected + rayleigh_factor * rayleigh_collected);

// color of the fog
vec4 final_color = vec4(color, 1.0);

float fog_quantity = 0.0;
if(v.y < 0.2)
	fog_quantity = 1.0-(v.y / 0.2);
fog_quantity = fog_quantity * fog_quantity;
	
if(v.y < 0.0)
	fog_quantity = 1.0;

float	_fade;
if (u_time_of_day < 0.5)
	_fade = u_time_of_day * 2.0;
else
	_fade = 1.0 - ((u_time_of_day - 0.5) * 2.0);

cloud_tex *= _fade;

float final_luma = (final_color.x + final_color.y + final_color.z) * 0.3333334;

final_color.x = final_color.x * 0.25 + final_luma * 0.75;
final_color.y = final_color.y * 0.25 + final_luma * 0.75;
final_color.z = final_color.z * 0.25 + final_luma * 0.75;

vec4 mountain_color = mix(vec4(fog_color * 0.5,1), vec4(ambient_color,1), 0.5);
mountain_color = mix(vec4(fog_color,1),vec4(35.0/255.0,81.0/255.0,152.0/255.0,1),0.5);
mountain_color = mix(final_color, mountain_color, 0.5);
mountain_color = mountain_color * 0.85;

final_color = mix(final_color, vec4(final_luma,final_luma,final_luma,1), 0.25);
final_color = mix(final_color, vec4(1,1,1,1), cloud_tex.x * 0.65);
final_color = mix(final_color, mountain_color, cloud_tex.y * cloud_tex.y);

%out.color% = mix(final_color, vec4(fog_color, 1.0), fog_quantity);
"
	>
>